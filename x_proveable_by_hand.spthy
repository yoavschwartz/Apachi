theory x_proveable_by_hand
begin

/*
 *  Author: Yoav S. & Nicolai S.
 *  Model Name: untrusted_reviewers.spthy
 *  Status: DEVELOPMENTAL
 *
 */

builtins: hashing, asymmetric-encryption, symmetric-encryption
functions: commit/2, commitRelationProof/2, checkCommitRelationProof/3, makeDiscussion/1, makeGrade/1,
           makeReview/2 [private], paper/1, randomness/1, gradeProof/2, checkGradeProof/3,
           revealSignCustom/2 [private], getMessageCustom/1
equations: getMessageCustom(revealSignCustom(m,sk)) = m


rule Generate_revealing_signature:
    [In(m), In(~sk)]
  --[KSign(revealSignCustom(m, ~sk))]->
    [Out(revealSignCustom(m, ~sk))]


/*
Create a log which an adversary can use
*/

rule Log_out:
    [Log_Out(m)]
  --[Outed(m)]->
    [!On_Log(m)]

rule Log_in:
    [!On_Log(m)]
  --[]->
    [Log_In(m)]

rule PublicLog_in:
    [In(m)]
  --[AdversaryIn(), PublicLog(<'Submission_1', m>)]->
    [!On_Log(m)]

rule PublicLog_out:
    [!On_Log(m)]
  --[AdversaryOut()]->
    [Out(m)]

/*
Setup actors
*/

rule Setup: 
    let 
    pc_pubk = pk(~pc_privk)
    in
    [Fr(~pc_privk)]
  --[OnlyOnceWith('Setup'),
     KeySecret(~pc_privk),
     PCPrivk(~pc_privk),
     PrivateKey(~pc_privk)]->
    [Setup_Submitter(pc_pubk), 
     Setup_PC($PC, ~pc_privk), 
     !Setup_Reviewer(pc_pubk),
     Reveal_Key_PC(~pc_privk)]

rule Setup_submitter:
    let
    pc_pubk = pk(~pc_privk)
    in
    [Setup_Submitter(pc_pubk), Fr(~S_privk)]
  --[OnlyOnceWith(<'Setup_Submitter', $Submitter>),
     KeySecret(~S_privk),
     PrivateKey(~S_privk),
     SubmitterPrivateKey(~S_privk)]->
    [!Submitter_Ready_To_Submit($Submitter, pc_pubk, ~S_privk),
     Reveal_Key_Other(~S_privk)]

rule Setup_pc:
    [Setup_PC($PC, ~pc_privk)]
  --[OnlyOnceWith('Setup_PC')]->
    [!PC($PC, ~pc_privk), Out(pk(~pc_privk))]

rule Setup_reviewer:
    let
    pc_pubk = pk(~pc_privk)
    in
    [!Setup_Reviewer(pc_pubk), Fr(~reviewer_key), Fr(~reviewer_privk)]
  --[ReviewerSetup($Reviewer, ~reviewer_key, ~reviewer_privk),
     OnlyOnceWith(<'Setup_Reviewer', $Reviewer>),
     KeySecret(~reviewer_key),
     KeySecret(~reviewer_privk),
     PrivateKey(~reviewer_privk)]->
    [!PC_Reviewer_Association($Reviewer, ~reviewer_key, pk(~reviewer_privk)),
     !Reviewer($Reviewer, ~reviewer_key, ~reviewer_privk, pc_pubk),
     Reveal_Key_PC(~reviewer_key),
     Reveal_Key_Other(~reviewer_key),
     Reveal_Key_Other(~reviewer_privk)]


/*
Key reveal
*/

rule Key_reveal_PC:
    [Reveal_Key_PC(key)]
  --[KeyRevealed(key), KeyRevealedPC(key)]->
    [Out(key)]

rule Key_reveal_Other:
    [Reveal_Key_Other(key)]
  --[KeyRevealed(key), KeyRevealedOther(key)]->
    [Out(key)]


/*
Phase 1: Submission
1. Submitter send paper to PC and commits to it on the log
2. PC receives the paper and commits to it on the log
*/

rule Submission_1_submitter_submits:
  let
    paper_commit = commit(paper(~paper), randomness(~r_submit))
    signed_paper_commit = revealSignCustom(paper_commit, ~S_privk)
    submission = senc(<paper(~paper), randomness(~r_submit), randomness(~r_review)>, ~submitter_key)
    signed_submission = revealSignCustom(submission, ~S_privk)
    submission_key = aenc(~submitter_key, pk(~pc_privk))
    signed_submission_key = revealSignCustom(submission_key, ~S_privk)
  in
    [Fr(~paper), Fr(~r_submit), Fr(~r_review), Fr(~submitter_key),
     !Submitter_Ready_To_Submit($Submitter, pk(~pc_privk), ~S_privk)]
  --[SubmittedPaper(~S_privk, paper(~paper)),
     SubmitterKnowledge(paper(~paper), ~S_privk, randomness(~r_submit), randomness(~r_review), ~submitter_key),
     PublicLog(<'Submission_1', signed_paper_commit>),
     PublicLog(<'Submission_1', signed_submission>),
     PublicLog(<'Submission_1', signed_submission_key>),
     KeySecret(~submitter_key)]->
    [Log_Out(signed_paper_commit),
     Log_Out(signed_submission),
     Log_Out(signed_submission_key),
     Reveal_Key_Other(~submitter_key)]

rule Submission_2_pc_receives_submission:
  let
    signed_submission = revealSignCustom(senc(<paper(~paper), randomness(~r_submit), randomness(~r_review)>, ~submitter_key), ~S_privk)
    signed_submission_key = revealSignCustom(aenc(~submitter_key, pk(~pc_privk)), ~S_privk)

    paper_commit = commit(paper(~paper), randomness(~r_submit))
    signed_paper_commit = revealSignCustom(paper_commit, ~pc_privk)
  in
    [!PC($PC, ~pc_privk),
     Fr(~group_key),
     Fr(~r_grade),
     Log_In(signed_submission),
     Log_In(signed_submission_key),
     Log_In(revealSignCustom(paper_commit, ~S_privk))]
  --[PCReceivedPaper(~pc_privk, paper_commit),
     PublicLog(<'Submission_2', signed_paper_commit>),
     OnlyOnceWith(<'Submission_2', ~paper>)]->
    [!Received_Submission(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key), 
     Log_Out(signed_paper_commit),
     !Group_For_Paper(paper(~paper), ~group_key, ~r_grade),
     Reveal_Key_PC(~group_key),
     Reveal_Key_PC(~submitter_key)]


/*
Phase 2: Matching
1. PC sends the paper to a Reviewer via the log
2. Reviewers sends bid to PC via the log
3. PC receives bid from the log & publishes makes a matching and publishes it to the log and sends matching secrets to the Reviewer via the log
*/

rule Matching_1_pc_sends_paper:
  let
    encrypted_paper = revealSignCustom(senc(paper(~paper), ~reviewer_key), ~pc_privk)
  in
    [!PC_Reviewer_Association($Reviewer, ~reviewer_key, pk(~reviewer_privk)), 
     !Received_Submission(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key),
     !PC($PC, ~pc_privk)]
  --[OnlyOnceWith(<'Matching_1', $Reviewer, ~paper>),
     PublicLog(<'Matching_1', encrypted_paper>),
     PCSendsPaperToReviewer($Reviewer, paper(~paper))]->
    [Log_Out(encrypted_paper),
     Send_Paper_To_Reviewer($Reviewer, paper(~paper))]

rule Matching_2_reviewer_sends_bids:
  let
  	encrypted_paper = revealSignCustom(senc(paper(~paper), ~reviewer_key), ~pc_privk)

  	encrypted_bid = senc(<h(paper(~paper)), 'bid'>, ~reviewer_key)
    signed_encrypted_bid = revealSignCustom(encrypted_bid, ~reviewer_privk)
  in
    [!Reviewer($Reviewer, ~reviewer_key, ~reviewer_privk, pk(~pc_privk)),
     Log_In(encrypted_paper)]
  --[BidOnPaper($Reviewer, ~reviewer_privk, ~reviewer_key, encrypted_bid, paper(~paper)),
     PublicLog(<'Matching_2', signed_encrypted_bid>),
     OnlyOnceWith(<'Matching_2', $Reviewer, ~paper>)]->
    [!Reviewer_Bid_On_Paper($Reviewer, paper(~paper)),
     Log_Out(signed_encrypted_bid)]

rule Matching_3_pc_matches_paper:
  let
    encrypted_bid = senc(<h(paper(~paper)), 'bid'>, ~reviewer_key)
    signed_encrypted_bid = revealSignCustom(encrypted_bid, ~reviewer_privk)

    review_paper_commit = commit(paper(~paper), randomness(~r_review))
    submit_paper_commit = commit(paper(~paper), randomness(~r_submit))
    matching = revealSignCustom(<review_paper_commit, pk(~reviewer_privk)>, ~pc_privk)
    matching_secret = revealSignCustom(senc(<h(paper(~paper)), ~group_key, randomness(~r_grade), randomness(~r_review)>, ~reviewer_key), ~pc_privk)
    commit_relation_proof = commitRelationProof(review_paper_commit, submit_paper_commit)
  in
    [!PC($PC, ~pc_privk),
     !Received_Submission(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key),
     !Group_For_Paper(paper(~paper), ~group_key, ~r_grade),
     !PC_Reviewer_Association($Reviewer, ~reviewer_key, pk(~reviewer_privk)),
     Send_Paper_To_Reviewer($Reviewer, paper(~paper)),
     Log_In(signed_encrypted_bid)]
  --[SentGroupKey($Reviewer, ~group_key),
     MatchedPaper(paper(~paper), $Reviewer, ~group_key),
     OnlyOnceWith(<'Matching_4', $Reviewer, ~paper>),
     KeySecret(~group_key),
     PublicLog(<'Matching_3', matching>),
     PublicLog(<'Matching_3', matching_secret>),
     PublicLog(<'Matching_3', commit_relation_proof>),
     RandomSecret(~r_grade)]->
    [PC_Waiting_For_Discussion(paper(~paper), randomness(~r_grade), $Reviewer, ~group_key),
     Log_Out(matching),
     Log_Out(matching_secret),
     Log_Out(commit_relation_proof)]

/*
Phase 3: Reviewing
1. Reviewer sends review text to PC via the log and commits to having written a review
*/

rule Reviewing_1_reviewer_sends_review:
  let
    review_paper_commit = commit(paper(~paper), randomness(~r_review))
  	matching = revealSignCustom(<review_paper_commit, pk(~reviewer_privk)>, ~pc_privk)
  	matching_secret = revealSignCustom(senc(<h(paper(~paper)), ~group_key, randomness(~r_grade), randomness(~r_review)>, ~reviewer_key), ~pc_privk)

    review = makeReview(paper(~paper), $Reviewer)
  	group_message = senc(revealSignCustom(review, ~reviewer_privk), ~group_key)
  	commit_paper_reviewed = revealSignCustom(<review_paper_commit, 'reviewed'>, ~reviewer_privk)
  in
    [!Reviewer_Bid_On_Paper($Reviewer, paper(~paper)),
     !Reviewer($Reviewer, ~reviewer_key, ~reviewer_privk, pk(~pc_privk)),
     Log_In(matching),
     Log_In(matching_secret)]
  --[GotGroupKey($Reviewer, ~group_key),
     ReviewedPaper($Reviewer, paper(~paper)),
     SecretReview(review),
     OnlyOnceWith(<'Reviewing_1', $Reviewer, ~paper>),
     PublicLog(<'Reviewing_1', group_message>),
     PublicLog(<'Reviewing_1', commit_paper_reviewed>),
     NotEq(~pc_privk, ~group_key)]->
    [!Reviewer_Reviewed_Paper($Reviewer, paper(~paper), randomness(~r_review), randomness(~r_grade), ~group_key),
     Start_Discussing($Reviewer, paper(~paper)),
     Log_Out(group_message),
     Log_Out(commit_paper_reviewed),
     Reveal_Key_Other(~group_key)]

/*
Phase 4: Discussion
1. Reviewer discuss and settle on a grade and sends to PC via log
2. PC receives discussion and grade from log
3. PC picks if paper is accepted or rejected and uncommits appropiate commits
*/

rule Discussion_1_1_reviewers_discuss:
  let
    discussion = makeDiscussion(paper(~paper))
    encrypted_discussion = senc(revealSignCustom(discussion, ~reviewer_privk), ~group_key)
  in
    [!Reviewer_Reviewed_Paper($Reviewer, paper(~paper), randomness(~r_review), randomness(~r_grade), ~group_key),
     !Reviewer($Reviewer, ~reviewer_key, ~reviewer_privk, pc_pubk),
     Start_Discussing($Reviewer, paper(~paper))]
  --[OnlyOnceWith(<'Discussion_1_1', $Reviewer, ~paper>),
     PublicLog(<'Discussion_1_1', encrypted_discussion>)]->
    [Ended_Discussing($Reviewer, paper(~paper)),
     Log_Out(encrypted_discussion)]

rule Discussion_1_2_finished_discussing:
  let
  	grade = makeGrade(paper(~paper))  
    encrypted_conclusion = senc(revealSignCustom(grade, ~reviewer_privk), ~group_key)
  	paper_review_commit = commit(paper(~paper), randomness(~r_review))
  	commit_paper_discussed = revealSignCustom(<paper_review_commit, 'discussed'>, ~reviewer_privk)
  	commit_paper_grade = commit(grade, randomness(~r_grade))
  	commit_paper_grade_signed = revealSignCustom(commit_paper_grade, ~reviewer_privk)
  in
    [Ended_Discussing($Reviewer, paper(~paper)),
     !Reviewer($Reviewer, ~reviewer_key, ~reviewer_privk, pk(~pc_privk)),
     !Reviewer_Reviewed_Paper($Reviewer, paper(~paper), randomness(~r_review), randomness(~r_grade), ~group_key)]
  --[OnlyOnceWith(<'Discussion_1_2', ~paper>),
     DiscussedPaper($Reviewer, paper(~paper)),
     GradeGiven($Reviewer, paper(~paper), grade, commit_paper_grade),
     PublicLog(<'Discussion_1_2', encrypted_conclusion>),
     PublicLog(<'Discussion_1_2', commit_paper_discussed>),
     PublicLog(<'Discussion_1_2', commit_paper_grade_signed>)]->
    [Log_Out(encrypted_conclusion),
     Log_Out(commit_paper_discussed),
     Log_Out(commit_paper_grade_signed)]

rule Discussion_2_pc_receives_discussion_and_grade:
  let
    discussion = makeDiscussion(paper(~paper))
    grade = makeGrade(paper(~paper))
    encrypted_discussion = senc(revealSignCustom(discussion, ~reviewer_privk), ~group_key)
    encrypted_conclusion = senc(revealSignCustom(grade, ~reviewer_privk), ~group_key)
    group_message = senc(revealSignCustom(makeReview(paper(~paper), $Reviewer), ~reviewer_privk), ~group_key)
    commit_paper_discussed = revealSignCustom(<commit(paper(~paper), randomness(~r_review)), 'discussed'>, ~reviewer_privk)
    submitter_response = senc(<discussion, grade, makeReview(paper(~paper), $Reviewer)>, ~submitter_key)
  in
    [!PC($PC, ~pc_privk),
     PC_Waiting_For_Discussion(paper(~paper), randomness(~r_grade), $Reviewer, ~group_key),
     !PC_Reviewer_Association($Reviewer, ~reviewer_key, pk(~reviewer_privk)),
     !Received_Submission(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key),
     Log_Out(commit_paper_discussed),
     Log_In(encrypted_discussion),
     Log_In(encrypted_conclusion),
     Log_In(group_message)]
  --[PCReceivedDiscussionFromReviewer($Reviewer, paper(~paper), ~group_key),
     OnlyOnceWith(<'Discussion_2', paper(~paper), $Reviewer>),
     PublicLog(<'Discussion_2', submitter_response>),
     SubmitterKeyUsed(~submitter_key)]->
    [Ready_For_Decision(paper(~paper), grade, randomness(~r_submit), randomness(~r_review), randomness(~r_grade), ~reviewer_privk, ~group_key),
     Log_Out(submitter_response)]

rule Discussion_3_1_pc_paper_accepted:
  let
    accepted = <paper(~paper), randomness(~r_submit), randomness(~r_review)>
    signed_accepted = revealSignCustom(accepted, ~pc_privk)
    grade = makeGrade(paper(~paper))
    signed_grade = revealSignCustom(grade, ~pc_privk)
    grade_proof = revealSignCustom(gradeProof(grade, commit(grade, randomness(~r_grade))), ~pc_privk)
  in
    [!PC($PC, ~pc_privk),
     Ready_For_Decision(paper(~paper), grade, randomness(~r_submit), randomness(~r_review), randomness(~r_grade), ~reviewer_privk, ~group_key),
     !PC_Reviewer_Association($Reviewer, ~reviewer_key, pk(~reviewer_privk))]
  --[PaperAccepted(commit(paper(~paper), randomness(~r_review))),
     BindReviewer($Reviewer, ~reviewer_key, ~reviewer_privk),
     PublicLog(<'Discussion_3_1', signed_accepted>),
     PublicLog(<'Discussion_3_1', signed_grade>),
     PublicLog(<'Discussion_3_1', grade_proof>),
     OnlyOnceWith(<'conclusion', ~paper>)]->
    [Log_Out(signed_accepted), 
     Log_Out(signed_grade),
     Log_Out(grade_proof)]

rule Discussion_3_2_pc_paper_rejected:
  let
    rejected_out = revealSignCustom(<commit(paper(~paper), randomness(~r_review)), randomness(~r_grade), grade>, ~pc_privk)
  in
    [!PC($PC, ~pc_privk),
     Ready_For_Decision(paper(~paper), grade, randomness(~r_submit), randomness(~r_review), randomness(~r_grade), ~reviewer_privk, ~group_key)]
  --[PaperRejected(commit(paper(~paper), randomness(~r_review))),
     PublicLog(<'Discussion_3_2', rejected_out>),
     OnlyOnceWith(<'conclusion', ~paper>)]->
    [Log_Out(rejected_out)]


/*
-------------------------------------------------------------------------------
===============================================================================
                                   Lemmas
===============================================================================
-------------------------------------------------------------------------------
*/


/*
=============
Helper lemmas
=============
*/

lemma helper_pc_signature_requires_pc_privk [reuse]:
"All pc_privk m #i #j.
  PCPrivk(pc_privk) @i &
  KSign(revealSignCustom(m, pc_privk)) @j
==>
  Ex #k. KeyRevealedPC(pc_privk) @k
"

lemma helper_pc_privk_requires_key_reveal_pc [reuse]:
"All pc_privk #i #j.
  PCPrivk(pc_privk) @i &
  K(pc_privk) @j
==>
  Ex #k. KeyRevealedPC(pc_privk) @k
"

lemma helper_signature_requires_privk [reuse]:
"All privk m #i #j.
  PrivateKey(privk) @i &
  KSign(revealSignCustom(m, privk)) @j
==>
  Ex #k. KeyRevealed(privk) @k
"

lemma helper_paper_accepted_not_rejected [reuse]:
"All p r #i.
 PaperAccepted(commit(p, r)) @i
 ==>
 not(Ex r #k. PaperRejected(commit(p, r)) @k)
"

lemma helper_paper_rejected_not_accepted [reuse]:
"All p r #i.
 PaperRejected(commit(p, r)) @i
 ==>
 not(Ex r #k. PaperAccepted(commit(p, r)) @k)
"


/*
=======================
Universal Verifiability
=======================
*/


//-------Paper accepted--------------------------------------------------------

lemma paper_accepted_verifiability_soundness_1_exists_trace_where_false:
exists-trace
"Ex p r_review #x.

  // Paper accepted
  PaperAccepted(commit(p, r_review)) @x

  &

  // The verifiability test is false
  not(Ex r_privk r_submit s_privk pc_privk grade grade_commit
         #k #l #m #n #o #p.

    // Paper submit commit log made by Submitter
    PublicLog(<'Submission_1', revealSignCustom(commit(p, r_submit), s_privk)>) @k &

    // Paper submit commit log made by PC
    PublicLog(<'Submission_2', revealSignCustom(commit(p, r_submit), pc_privk)>) @l &

    // Paper matching log made by PC
    PublicLog(<'Matching_3', revealSignCustom(<commit(p, r_review), pk(r_privk)>, pc_privk)>) @m &

    // Paper review commit log made by Reviewer
    PublicLog(<'Reviewing_1', revealSignCustom(<commit(p, r_review), 'reviewed'>, r_privk)>) @n &

    // Paper discussion commit log made by Reviewer
    PublicLog(<'Discussion_1_2', revealSignCustom(<commit(p, r_review), 'discussed'>, r_privk)>) @o &

    // Paper grade commit log made by Reviewer
    PublicLog(<'Discussion_1_2', revealSignCustom(grade_commit, r_privk)>) @o &

    // Grade reveal log made by PC
    PublicLog(<'Discussion_3_1', revealSignCustom(grade, pc_privk)>) @p &

    // Grade proof log made by PC (this is modelled as a one to one proof, but the protocol has a many to many proof instead)
    PublicLog(<'Discussion_3_1', revealSignCustom(gradeProof(grade, grade_commit), pc_privk)>) @p &

    // Paper acceptance log made by PC
    PublicLog(<'Discussion_3_1', revealSignCustom(<p, r_submit, r_review>, pc_privk)>) @p &

    // Making sure that things happen in right order
    #k < #l &
    #l < #m &
    #m < #n &
    #n < #o &
    #o < #p
  )
"


//-------Paper rejected--------------------------------------------------------

lemma paper_rejected_verifiability_soundness_1_exists_trace_where_false:
exists-trace
"Ex review_commit #x.

  // Paper rejected
  PaperRejected(review_commit) @x

  &

  // The verifiability test is false
  not(Ex s_privk r_privk submit_commit review_commit pc_privk r_grade grade
         #i #j #k #l #m #n.

    // Paper submit commit log made by Submitter
    PublicLog(<'Submission_1', revealSignCustom(submit_commit, s_privk)>) @i &

    // Paper submit commit log made by PC
    PublicLog(<'Submission_2', revealSignCustom(submit_commit, pc_privk)>) @j &

    // Paper matching log made by PC
    PublicLog(<'Matching_3', revealSignCustom(<review_commit, pk(r_privk)>, pc_privk)>) @k &

    // Proof that submit and review commit are hiding the same paper log by PC
    PublicLog(<'Matching_3', commitRelationProof(review_commit, submit_commit)>) @k &

    // Paper review commit log made by Reviewer
    PublicLog(<'Reviewing_1', revealSignCustom(<review_commit, 'reviewed'>, r_privk)>) @l &

    // Paper discussion commit log made by Reviewer
    PublicLog(<'Discussion_1_2', revealSignCustom(<review_commit, 'discussed'>, r_privk)>) @m &

    // Paper grade commit log made by Reviewer
    PublicLog(<'Discussion_1_2', revealSignCustom(commit(grade, r_grade), r_privk)>) @m &

    // Paper rejected log made by PC
    PublicLog(<'Discussion_3_2', revealSignCustom(<review_commit, r_grade, grade>, pc_privk)>) @n &

    // Making sure that things happen in right order
    #i < #j &
    #j < #k &
    #k < #l &
    #l < #m &
    #m < #n
  )
"


/*
===================
Accountability - PC
===================
*/


//-------Paper accepted--------------------------------------------------------

lemma paper_accepted_accountability_soundness_1_exists_trace_where_false:
exists-trace
"Ex p r_review #x.

  // Paper accepted
  PaperAccepted(commit(p, r_review)) @x

  &

  not(Ex k #a. KeyRevealedOther(k) @a)

  &

  // The accountability test is true
  not(Ex r_privk r_submit pc_privk grade grade_commit
         #l #m #n #o #p.

    // Paper submit commit log made by PC
    PublicLog(<'Submission_2', revealSignCustom(commit(p, r_submit), pc_privk)>) @l &

    // Paper matching log made by PC
    PublicLog(<'Matching_3', revealSignCustom(<commit(p, r_review), pk(r_privk)>, pc_privk)>) @m &

    // Paper review commit log made by Reviewer
    PublicLog(<'Reviewing_1', revealSignCustom(<commit(p, r_review), 'reviewed'>, r_privk)>) @n &

    // Paper discussion commit log made by Reviewer
    PublicLog(<'Discussion_1_2', revealSignCustom(<commit(p, r_review), 'discussed'>, r_privk)>) @o &

    // Paper grade commit log made by Reviewer
    PublicLog(<'Discussion_1_2', revealSignCustom(grade_commit, r_privk)>) @o &

    // Grade reveal log made by PC
    PublicLog(<'Discussion_3_1', revealSignCustom(grade, pc_privk)>) @p &

    // Grade proof log made by PC (this is modelled as a one to one proof, but the protocol has a many to many proof instead)
    PublicLog(<'Discussion_3_1', revealSignCustom(gradeProof(grade, grade_commit), pc_privk)>) @p &

    // Paper acceptance log made by PC
    PublicLog(<'Discussion_3_1', revealSignCustom(<p, r_submit, r_review>, pc_privk)>) @p &

    // Making sure that things happen in right order
    #l < #m &
    #m < #n &
    #n < #o &
    #o < #p
  )
"


//-------Paper rejected--------------------------------------------------------

lemma paper_rejected_accountability_soundness_1_exists_trace_where_false:
exists-trace
"Ex review_commit #x.

  // Paper rejected
  PaperRejected(review_commit) @x

  &

  not(Ex k #a. KeyRevealedOther(k) @a)

  &

  // The accountability test is true
  not(Ex s_privk r_privk submit_commit pc_privk r_grade grade
         #i #j #k #l #m #n.

    // Paper submit commit log made by Submitter
    PublicLog(<'Submission_1', revealSignCustom(submit_commit, s_privk)>) @i &

    // Paper submit commit log made by PC
    PublicLog(<'Submission_2', revealSignCustom(submit_commit, pc_privk)>) @j &

    // Paper matching log made by PC
    PublicLog(<'Matching_3', revealSignCustom(<review_commit, pk(r_privk)>, pc_privk)>) @k &

    // Proof that submit and review commit are hiding the same paper log by PC
    PublicLog(<'Matching_3', commitRelationProof(review_commit, submit_commit)>) @k &

    // Paper review commit log made by Reviewer
    PublicLog(<'Reviewing_1', revealSignCustom(<review_commit, 'reviewed'>, r_privk)>) @l &

    // Paper discussion commit log made by Reviewer
    PublicLog(<'Discussion_1_2', revealSignCustom(<review_commit, 'discussed'>, r_privk)>) @m &

    // Paper grade commit log made by Reviewer
    PublicLog(<'Discussion_1_2', revealSignCustom(commit(grade, r_grade), r_privk)>) @m &

    // Paper rejected log made by PC
    PublicLog(<'Discussion_3_2', revealSignCustom(<review_commit, r_grade, grade>, pc_privk)>) @n &

    // Making sure that things happen in right order
    #i < #j &
    #j < #k &
    #k < #l &
    #l < #m &
    #m < #n
  )
"


/*
=======================
Individual Verifiability
=======================
*/

lemma paper_rejected_submitter_verifiability_soundness_1_exists_trace_where_false:
exists-trace
"Ex p r_review s_privk #x #y.

  // Paper rejected
  PaperRejected(commit(p, r_review)) @x

  &

  // Honest Submitter
  SubmitterPrivateKey(s_privk) @y &
  not(Ex #a. KeyRevealed(s_privk) @a)

  &

  // The verifiability test is false
  not(Ex discussion review s_key r_submit pc_privk r_privk grade r_grade
         #h #i #j #k #l #m #n #o.

    // Submitter knowledge
    SubmitterKnowledge(p, s_privk, r_submit, r_review, s_key) @h &

    // Paper submit commit log made by Submitter
    PublicLog(<'Submission_1', revealSignCustom(commit(p, r_submit), s_privk)>) @i &

    // Paper submit commit log made by PC
    PublicLog(<'Submission_2', revealSignCustom(commit(p, r_submit), pc_privk)>) @j &

    // Paper matching log made by PC
    PublicLog(<'Matching_3', revealSignCustom(<commit(p, r_review), pk(r_privk)>, pc_privk)>) @k &

    // Proof that submit and review commit are hiding the same paper log by PC
    PublicLog(<'Matching_3', commitRelationProof(commit(p, r_review), commit(p, r_submit))>) @k &

    // Paper review commit log made by Reviewer
    PublicLog(<'Reviewing_1', revealSignCustom(<commit(p, r_review), 'reviewed'>, r_privk)>) @l &

    // Paper discussion commit log made by Reviewer
    PublicLog(<'Discussion_1_2', revealSignCustom(<commit(p, r_review), 'discussed'>, r_privk)>) @m &

    // Paper grade commit log made by Reviewer
    PublicLog(<'Discussion_1_2', revealSignCustom(commit(grade, r_grade), r_privk)>) @m &

    // Submitter response log made by PC
    PublicLog(<'Discussion_2', senc(<discussion, grade, review>, s_key)>) @n &

    // Paper rejected log made by PC
    PublicLog(<'Discussion_3_2', revealSignCustom(<commit(p, r_review), r_grade, grade>, pc_privk)>) @o &

    // Making sure that things happen in right order
    #i < #j &
    #j < #k &
    #k < #l &
    #l < #m &
    #m < #n &
    #n < #o
  )
"


lemma sanity_one:
exists-trace
"Ex S_privk PC_privk R p r1  R_key R_privk b g_k r2
    #h #i #j #k #l #m #n #o #p #q.
    ReviewerSetup(R, R_key, R_privk) @h
    & SubmittedPaper(S_privk, p) @i
    & PCReceivedPaper(PC_privk, commit(p,r1)) @j
    & PCSendsPaperToReviewer(R, p) @k
    & BidOnPaper(R, R_privk, R_key, b, p) @l
    & MatchedPaper(p, R, g_k) @m
    & ReviewedPaper(R, p) @n
    & DiscussedPaper(R, p) @o
    & PCReceivedDiscussionFromReviewer(R, p, g_k) @p
    & PaperAccepted(commit(p,r2)) @q
    & BindReviewer(R, R_key, R_privk) @q
"

lemma sanity_only_paper_accepted:
exists-trace
"Ex p r #r.
   PaperAccepted(commit(p,r)) @r
"

lemma sanity_only_paper_rejected:
exists-trace
"Ex p r #r.
   PaperRejected(commit(p,r)) @r
"

//Restrictions
// restriction Eq:
// " All x y #i. Eq(x,y) @i ==> x = y
// "

restriction NotEq:
"All x y #i. NotEq(x,y) @i ==> not(x = y)"

restriction OnlyOnceWith:
"All x #i #j. OnlyOnceWith(x) @i & OnlyOnceWith(x) @j ==> #i = #j"


end
