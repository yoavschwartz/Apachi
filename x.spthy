theory x
begin

/*
 *  Author: 
 *  Model Name: x.spthy
 *  Status: DEVELOPMENTAL
 *
 */

builtins: symmetric-encryption, hashing, asymmetric-encryption, revealing-signing
functions: commit/2, revealCommit/1 [private], revealCommitR/1 [private], revealCommitM/1 [private], fstOfQuad/1, sndOfQuad/1, thrdOfQuad/1, frthOfQuad/1
equations: revealCommit(commit(m, r)) = <m,r>,
             revealCommitR(commit(m, r)) = r,
             revealCommitM(commit(m, r)) = m,
           fstOfQuad(<a,b,c,d>) = fst(<a,b,c,d>),
           sndOfQuad(<a,b,c,d>) = fst(snd(<a,b,c,d>)),
           thrdOfQuad(<a,b,c,d>) = fst(snd(snd(<a,b,c,d>))),
           frthOfQuad(<a,b,c,d>) = snd(snd(snd(<a,b,c,d>))) 

/*
 * Setting up our own secure, authenticated and replay resistant channels.
 * A: Sender
 * B: Receiver
 * x: message
 */
rule Setup: 
    let 
    pc_pubk = pk(~pc_privk)
    in
    [Fr(~pc_privk)]
  --[OnlyOnceWith('Setup')]->
    [Setup_Submitter(pc_pubk), 
     Setup_PC($PC, ~pc_privk), 
     !Setup_Reviewer(pc_pubk)]

rule Setup_submitter:
    let
    pc_pubk = pk(~pc_privk)
    in
    [Setup_Submitter(pc_pubk)]
  --[]->
    [!Submitter_Ready_To_Submit($Submitter, pc_pubk)]

rule Setup_pc:
    [Setup_PC($PC, ~pc_privk)]
  --[]->
    [!PC($PC, ~pc_privk)]

rule Setup_reviewer:
    let
    pc_pubk = pk(~pc_privk)
    in
    [!Setup_Reviewer(pc_pubk), Fr(~key), Fr(~reviewer_privk)]
  --[]->
    [!Reviewer_Ready_For_Matching($Reviewer, ~key, ~reviewer_privk, pc_pubk),
     !PC_Reviewer_Association($Reviewer, ~key, pk(~reviewer_privk))]

/*
Phase 1: Submission
1. Submitter send paper and abstract to S
2. S sends submitter a receipt
3. S sends papers to PC
4. PC publicly commits to submitted papers and whether or not they will go forward in the process
*/

rule Submission_1_submitter_submits:
  let
    pc_pubk = pk(~pc_privk)
    commit1 = commit(~paper, ~r_paper1)
    commit2 = commit(~paper, ~r_paper2)
    commit3 = commit(~abstract, ~r_abstract1)
    commit4 = commit(~abstract, ~r_abstract2)
    commits = <commit1, commit2, commit3, commit4>
    submission = <senc(commits, ~key), aenc(~key, pc_pubk)>
  in
    [!Submitter_Ready_To_Submit($Submitter, pc_pubk),
     Fr(~paper), Fr(~abstract), Fr(~key), Fr(~r_abstract1), Fr(~r_abstract2), Fr(~r_paper1), Fr(~r_paper2)]
  --[SubmittedPaper(~paper, ~abstract, commits)]->
    [Out(submission),
     Submitter_Did_Submit($Submitter, ~key, commits, pc_pubk)]

rule Submission_2_pc_receives_submission:
  let
    commit1 = commit(~paper, ~r_paper1)
    commit2 = commit(~paper, ~r_paper2)
    commit3 = commit(~abstract, ~r_abstract1)
    commit4 = commit(~abstract, ~r_abstract2)
    commits = <commit1, commit2, commit3, commit4>
    submission = <senc(commits, ~key), aenc(~key, pc_pubk)>
    key = adec(snd(submission), ~pc_privk)
    submitted_commits = sdec(fst(submission), ~key)
    commit_paper = fstOfQuad(submitted_commits)
    commit_abstract = thrdOfQuad(submitted_commits)
  in
    [!PC($PC, ~pc_privk), In(submission)]
  --[CommitPaper(commit_paper), 
     CommitAbstract(commit_abstract),
     OnlyOnceWith(submission)]->
    [!Received_Submission(submitted_commits, ~key), 
     Out(<commit_paper, commit_abstract>)]


/*
Phase 2: Matching
1. PC sends a list of all abstracts
3. Reviewers sends a list of bids
5. PC publishes the matching and a list of anonymized Reviewers and their bids
*/

rule Matching_1_pc_sends_abstracts:
  let
    encrypted_commit = senc(frthOfQuad(submitted_commits), ~reviewer_key) 
  in
    [!PC_Reviewer_Association($Reviewer, ~reviewer_key, reviewer_pubk), 
     !Received_Submission(submitted_commits, submitter_key),
     !PC($PC, ~pc_privk)]
  --[OnlyOnceWith(<encrypted_commit, $Reviewer>)]->
    [Out(encrypted_commit)]

rule Matching_2_reviewer_sends_bids:
  let
    commit = commit(~abstract, ~r_abstract2)
    encrypted_commit = senc(commit, ~reviewer_key)
    abstract = revealCommitM(commit)
    abstract_r = revealCommitR(commit)
    signed_bid = revealSign(<commit, ~bid>, ~reviewer_privk)
    encrypted_bid = senc(signed_bid, ~key)
  in
    [!Reviewer_Ready_For_Matching($Reviewer, ~key, ~reviewer_privk, pc_pubk),
     In(encrypted_commit), Fr(~bid)]
  --[BidOnAbstract($Reviewer, ~reviewer_privk, abstract, abstract_r, ~bid),
     OnlyOnceWith(<$Reviewer, abstract>)]->
    [Reviewer_Bid_On_Abstract($Reviewer, ~key, ~reviewer_privk, pc_pubk, encrypted_bid),
     Out(encrypted_bid)]

rule Matching_3_pc_receives_bid:
  let
    commit = sdec(encrypted_commit, ~key)
    abstract = revealCommitM(commit)
    abstract_r = revealCommitR(commit)
    signed_bid = revealSign(<commit, ~bid>, ~reviewer_privk)
    encrypted_bid = senc(signed_bid, ~key)
    bid = getMessage(signed_bid)
    commit = fst(bid)
    paper = revealCommitM(sndOfQuad(submitted_commits))
  in
    [!PC($PC, ~pc_privk), 
     In(encrypted_bid),
     !Received_Submission(submitted_commits, submitter_key),
     !PC_Reviewer_Association($Reviewer, ~reviewer_key, pk(~reviewer_privk))]
  --[CommitBid(signed_bid),
     Eq(commit, frthOfQuad(submitted_commits)),
     Eq(revealVerify(signed_bid, bid, pk(~reviewer_privk)), true)
     OnlyOnceWith(<$Reviewer, paper>)]->
    [Matching_Ready($Reviewer, paper),
     Out(signed_bid)]

rule Matching_4_pc_matches_paper:
    [Matching_Ready($Reviewer, paper)]
  --[MatchedPaper($Reviewer, paper)]->
    [Paper_Matched($Reviewer, paper)]

/*
Phase 3: Reviewing
1. PC sends a list of all abstracts
3. Reviewers sends a list of bids
5. PC publishes the matching and a list of anonymized Reviewers and their bids
*/

lemma sanity_one_submission:
exists-trace
"Ex p a rp1 rp2 ra1 ra2 R b r_privk #i #j #k #l.
    SubmittedPaper(p, a, <commit(p, rp1), commit(p, rp2), commit(a, ra1), commit(a, ra2)>) @i &
    CommitPaper(commit(p, rp1)) @j &
    CommitAbstract(commit(a, ra1)) @j &
    BidOnAbstract(R, r_privk, a, ra2, b) @k &
    CommitBid(revealSign(<commit(a, ra2), b>, r_privk)) @l
"

// lemma sanity_multiple_submissions:
// exists-trace
// "Ex p1 a1 p2 a2 r1 r2 #i #j #k #l.
//     SubmittedPaper(p1, a1, r1) @i &
//     CommitPaper(commit(p1, r1)) @k &
//     CommitAbstract(commit(a1, r1)) @k &
//     SubmittedPaper(p2, a2, r2) @j &
//     CommitPaper(commit(p2, r2)) @l &
//     CommitAbstract(commit(a2, r2)) @l &
//     not(p1 = p2) &
//     not(a1 = a2) &
//     not(r1 = r2) &
//     i < k &
//     j < l
// "


//Restrictions
restriction Eq:
" All x y #i. Eq(x,y) @i ==> x = y
    
"

// restriction NotEq:
// " All x y #i. NotEq(x,y) @i ==> not(x = y)
    
// "

restriction OnlyOnceWith:
" All x #i #j. OnlyOnceWith(x) @i & OnlyOnceWith(x) @j ==> #i=#j
    
"

end