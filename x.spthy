{"COMMITS": "paper_submission_commit = commit(~paper, ~r_paper1) \npaper_review_commit = commit(~paper, ~r_paper2) \n abstract_submission_commit = commit(abstractFromPaper(~paper), ~r_abstract1) \n abstract_review_commit = commit(abstractFromPaper(~paper), ~r_abstract2) \n commits = <paper_submission_commit, paper_review_commit, abstract_submission_commit, abstract_review_commit>"}
^
theory x
begin

/*
 *  Author: 
 *  Model Name: x.spthy
 *  Status: DEVELOPMENTAL
 *
 */

builtins: symmetric-encryption, hashing, asymmetric-encryption, revealing-signing
functions: commit/2, revealCommit/1 [private], revealCommitR/1 [private], revealCommitM/1 [private], 
           fstOfQuad/1, sndOfQuad/1, thrdOfQuad/1, frthOfQuad/1, abstractFromPaper/1, makeDiscussion/1, makeGrade/1
equations: revealCommit(commit(m, r)) = <m,r>,
           revealCommitR(commit(m, r)) = r,
           revealCommitM(commit(m, r)) = m,
           fstOfQuad(<a,b,c,d>) = fst(<a,b,c,d>),
           sndOfQuad(<a,b,c,d>) = fst(snd(<a,b,c,d>)),
           thrdOfQuad(<a,b,c,d>) = fst(snd(snd(<a,b,c,d>))),
           frthOfQuad(<a,b,c,d>) = snd(snd(snd(<a,b,c,d>))) 


rule TestOut:
    [TestOut(m)]
  --[  ]->
    [TestIn(m)]

/*
 * Setting up our own secure, authenticated and replay resistant channels.
 * A: Sender
 * B: Receiver
 * x: message
 */
rule Setup: 
    let 
    pc_pubk = pk(~pc_privk)
    in
    [Fr(~pc_privk)]
  --[OnlyOnceWith('Setup')]->
    [Setup_Submitter(pc_pubk), 
     Setup_PC($PC, ~pc_privk), 
     !Setup_Reviewer(pc_pubk)]

rule Setup_submitter:
    let
    pc_pubk = pk(~pc_privk)
    in
    [Setup_Submitter(pc_pubk)]
  --[]->
    [!Submitter_Ready_To_Submit($Submitter, pc_pubk)]

rule Setup_pc:
    [Setup_PC($PC, ~pc_privk)]
  --[]->
    [!PC($PC, ~pc_privk)]

rule Setup_reviewer:
    let
    pc_pubk = pk(~pc_privk)
    in
    [!Setup_Reviewer(pc_pubk), Fr(~key), Fr(~reviewer_privk)]
  --[]->
    [!Reviewer_Ready_For_Matching($Reviewer, ~key, ~reviewer_privk, pc_pubk),
     !PC_Reviewer_Association($Reviewer, ~key, pk(~reviewer_privk))]

/*
Phase 1: Submission
1. Submitter send paper and abstract to S
2. S sends submitter a receipt
3. S sends papers to PC
4. PC publicly commits to submitted papers and whether or not they will go forward in the process
*/

rule Submission_1_submitter_submits:
  let
    abstract = abstractFromPaper(~paper)
    pc_pubk = pk(~pc_privk)
        paper_submission_commit = commit(~paper, ~r_paper1) 
paper_review_commit = commit(~paper, ~r_paper2) 
 abstract_submission_commit = commit(abstractFromPaper(~paper), ~r_abstract1) 
 abstract_review_commit = commit(abstractFromPaper(~paper), ~r_abstract2) 
 commits = <paper_submission_commit, paper_review_commit, abstract_submission_commit, abstract_review_commit>
    submission = <senc(commits, ~key), aenc(~key, pc_pubk)>
  in
    [!Submitter_Ready_To_Submit($Submitter, pc_pubk),
     Fr(~paper), Fr(~key), Fr(~r_abstract1), Fr(~r_abstract2), Fr(~r_paper1), Fr(~r_paper2)]
  --[SubmittedPaper(~paper, abstract, commits)]->
    [TestOut(submission),
     Submitter_Did_Submit($Submitter, ~key, commits, pc_pubk)]

rule Submission_2_pc_receives_submission:
  let
    COMMITS
    submission = <senc(commits, ~key), aenc(~key, pc_pubk)> 
    submitter_key = adec(snd(submission), ~pc_privk)
    submitted_commits = sdec(fst(submission), submitter_key)
  in
    [!PC($PC, ~pc_privk), TestIn(submission)]
  --[CommitPaper(paper_submission_commit),
     CommitAbstract(abstract_submission_commit),
     OnlyOnceWith(submission)]->
    [!Received_Submission(submitted_commits, submitter_key), 
     TestOut(<'log', paper_submission_commit, abstract_submission_commit>)]


/*
Phase 2: Matching
1. PC sends a list of all abstracts
3. Reviewers sends a list of bids
5. PC publishes the matching and a list of anonymized Reviewers and their bids
*/

rule Matching_1_pc_sends_abstracts:
  let
    encrypted_commit = senc(frthOfQuad(submitted_commits), ~reviewer_key) 
  in
    [!PC_Reviewer_Association($Reviewer, ~reviewer_key, reviewer_pubk), 
     !Received_Submission(submitted_commits, submitter_key),
     !PC($PC, ~pc_privk)]
  --[OnlyOnceWith(<encrypted_commit, $Reviewer>)]->
    [TestOut(encrypted_commit)]

rule Matching_2_reviewer_sends_bids:
  let
    abstract = abstractFromPaper(~paper)
    commit = commit(abstract, ~abstract_r)
    encrypted_commit = senc(commit, ~key)   
    signed_bid = revealSign(<commit, ~bid>, ~reviewer_privk)
    encrypted_bid = senc(signed_bid, ~key)
  in
    [!Reviewer_Ready_For_Matching($Reviewer, ~key, ~reviewer_privk, pc_pubk),
     TestIn(encrypted_commit),
     Fr(~bid)]
  --[BidOnAbstract($Reviewer, ~reviewer_privk, abstract, ~abstract_r, ~bid),
     OnlyOnceWith(<$Reviewer, abstract>)]->
    [Reviewer_Bid_On_Abstract($Reviewer, ~key, ~reviewer_privk, pc_pubk, encrypted_bid),
     TestOut(encrypted_bid)]

rule Matching_3_pc_receives_bid:
  let
        paper_submission_commit = commit(~paper, ~r_paper1) 
paper_review_commit = commit(~paper, ~r_paper2) 
 abstract_submission_commit = commit(abstractFromPaper(~paper), ~r_abstract1) 
 abstract_review_commit = commit(abstractFromPaper(~paper), ~r_abstract2) 
 commits = <paper_submission_commit, paper_review_commit, abstract_submission_commit, abstract_review_commit>
    abstract_review_commit = commit(abstractFromPaper(~paper), ~r_abstract2)
    signed_bid = revealSign(<abstract_review_commit, ~bid>, ~reviewer_privk)
    encrypted_bid = senc(signed_bid, ~reviewer_key)
  in
    [!PC($PC, ~pc_privk), 
     !Received_Submission(submitted_commits, submitter_key),
     !PC_Reviewer_Association($Reviewer, ~reviewer_key, pk(~reviewer_privk)),
     TestIn(encrypted_bid)]
  --[CommitBid(signed_bid)
     ,Eq(commit(abstractFromPaper(~paper), ~r_abstract2), frthOfQuad(submitted_commits))
     ,Eq(revealVerify(signed_bid, <abstract_review_commit, ~bid>, pk(~reviewer_privk)), true)
     ,OnlyOnceWith(<$Reviewer, ~paper>)
     ]->
    [Matching_Ready($Reviewer, pk(~reviewer_privk), ~paper),
     TestOut(<'log',signed_bid>)]

rule Matching_4_pc_matches_paper:
    [Matching_Ready($Reviewer, pk(~reviewer_privk), paper)]
  --[MatchedPaper($Reviewer, paper)]->
    [!Paper_Matched($Reviewer, pk(~reviewer_privk), paper)]

/*
Phase 3: Reviewing
1. PC sends paper to reviewer
2. Reviewer sends review text and score signs the review text and score and sings a commit to the paper
3. PC outs the signed commit to the paper (review)
*/

rule Reviewing_1_pc_sends_paper:
  let
    paper = revealCommitM(sndOfQuad(submitted_commits))
    encrypted_commit = senc(sndOfQuad(submitted_commits), ~reviewer_key) 
  in
    [!PC_Reviewer_Association($Reviewer, ~reviewer_key, reviewer_pubk), 
     !Received_Submission(submitted_commits, submitter_key),
     !Paper_Matched($Reviewer, pk(~reviewer_privk), paper),
     !PC($PC, ~pc_privk)]
  --[OnlyOnceWith(<$Reviewer, paper, 'reviewing'>)]->
    [TestOut(encrypted_commit), Waiting_For_Review($Reviewer, paper)]

rule Reviewing_2_reviewer_sends_review:
  let
    commit = sdec(encrypted_commit, ~key)    
    paper = revealCommitM(commit)
    paper_r = revealCommitR(commit)
    bidded_abstract = revealCommitM(fst(getMessage(sdec(encrypted_bid, ~key))))
    signed_commit = revealSign(commit, ~reviewer_privk)
    signed_review = revealSign(<~review_score, ~review_text>, ~reviewer_privk)
    encrypted_review = senc(<signed_commit, signed_review>, ~key)

  in
    [Reviewer_Bid_On_Abstract($Reviewer, ~key, ~reviewer_privk, pc_pubk, encrypted_bid),
     TestIn(encrypted_commit),
     Fr(~review_text),
     Fr(~review_score)]
  --[Eq(abstractFromPaper(paper), bidded_abstract),
     ReviewedPaper($Reviewer, paper)]->
    [TestOut(encrypted_review),
     Reviewer_Reviewed_Paper($Reviewer, ~key, ~reviewer_privk, pc_pubk, ~review_score, ~review_text, paper, paper_r)]

rule Reviewing_3_pc_receives_review:
  let
  	    paper_submission_commit = commit(~paper, ~r_paper1) 
paper_review_commit = commit(~paper, ~r_paper2) 
 abstract_submission_commit = commit(abstractFromPaper(~paper), ~r_abstract1) 
 abstract_review_commit = commit(abstractFromPaper(~paper), ~r_abstract2) 
 commits = <paper_submission_commit, paper_review_commit, abstract_submission_commit, abstract_review_commit>
    signed_commit_and_review = sdec(encrypted_commit_and_review, ~reviewer_key)
    signed_commit = fst(signed_commit_and_review)
    signed_review = snd(signed_commit_and_review)
  in
    [!PC($PC, ~pc_privk), 
     !Received_Submission(submitted_commits, submitter_key),
     Waiting_For_Review($Reviewer, ~paper),
     !PC_Reviewer_Association($Reviewer, ~reviewer_key, pk(~reviewer_privk)),
     TestIn(encrypted_commit_and_review)]
  --[Eq(revealVerify(signed_commit, paper_review_commit, pk(~reviewer_privk)), true),
     Eq(revealVerify(signed_review, getMessage(signed_review), pk(~reviewer_privk)), true),
     ReceivedReview($Reviewer, ~paper)]->
    [Received_Review($Reviewer, ~paper, signed_review),
     TestOut(<'log', signed_commit>)]

/*
Phase 4: Discussion
1. PC sends reviews and the group key to reviewer
2. Reviewer discuss and settle on a grade/recommendation and sends to PC
3. PC outs the signed commit to the paper (grade)
*/

rule Discussion_1_pc_sends_review:
  let
    encrypted_review_and_key_1 = senc(<signed_review2, ~group_key>, ~reviewer_key1)
    encrypted_review_and_key_2 = senc(<signed_review1, ~group_key>, ~reviewer_key2)
  in
    [!PC_Reviewer_Association($Reviewer1, ~reviewer_key1, reviewer_pubk1),
     !PC_Reviewer_Association($Reviewer2, ~reviewer_key2, reviewer_pubk2), 
     Received_Review($Reviewer1, ~paper, signed_review1),
     Received_Review($Reviewer2, ~paper, signed_review2),
     !Received_Submission(submitted_commits, submitter_key),
     !PC($PC, ~pc_privk), Fr(~group_key)]
  --[NotEq($Reviewer1, $Reviewer2)]->
    [TestOut(encrypted_review_and_key_1), TestOut(encrypted_review_and_key_2),
     PC_Waiting_For_Discussion(~paper, $Reviewer1, $Reviewer2, ~group_key)]

rule Discussion_2_reviewers_discuss:
  let
  	signed_review2 = revealSign(<~review_score2, ~review_text2>, ~reviewer2_privk)
    encrypted_review_and_key = senc(<signed_review2, ~group_key>, ~key)
    discussion = makeDiscussion(~paper)
    grade = makeGrade(~paper)
    signed_discussion = revealSign(discussion, reviewer_privk)
    signed_grade = revealSign(grade, reviewer_privk)
    signed_grade_commit = revealSign(commit(grade, ~paper_r), ~reviewer_privk)
    encrypted_discussion_and_grade = senc(<signed_discussion, signed_grade, signed_grade_commit>, ~group_key)
  in
    [Reviewer_Reviewed_Paper($Reviewer, ~key, ~reviewer_privk, pc_pubk, ~review_score, ~review_text, ~paper, ~paper_r),
     !Paper_Matched($Reviewer2, pk(~reviewer2_privk), ~paper),
     TestIn(encrypted_review_and_key)]
  --[NotEq($Reviewer1, $Reviewer2)]->
    [TestOut(encrypted_discussion_and_grade)]

rule Discussion_3_PC_recieves_discussion:
  let
    signed_discussion1 = revealSign(makeDiscussion(~paper), reviewer_privk1)
    signed_grade1 = revealSign(makeGrade(~paper), reviewer_privk1)
    signed_grade_commit1 = revealSign(commit(makeGrade(~paper), ~paper_r), ~reviewer_privk1)
    encrypted_discussion_and_grade1 = senc(<signed_discussion1, signed_grade1, signed_grade_commit1>, ~group_key)

    signed_discussion2 = revealSign(makeDiscussion(~paper), reviewer_privk2)
    signed_grade2 = revealSign(makeGrade(~paper), reviewer_privk2)
    signed_grade_commit2 = revealSign(commit(makeGrade(~paper), ~paper_r), ~reviewer_privk2)
    encrypted_discussion_and_grade2 = senc(<signed_discussion2, signed_grade2, signed_grade_commit2>, ~group_key)
  in
    [PC_Waiting_For_Discussion(~paper, $Reviewer1, $Reviewer2, ~group_key),
     !PC_Reviewer_Association($Reviewer1, ~reviewer_key1, pk(reviewer_privk1)),
     !PC_Reviewer_Association($Reviewer2, ~reviewer_key2, pk(reviewer_privk2)), 
     TestIn(encrypted_discussion_and_grade1),
     TestIn(encrypted_discussion_and_grade2)]
  --[NotEq($Reviewer1, $Reviewer2)]->
    [TestOut(encrypted_discussion_and_grade)]


lemma sanity_one_submission:
exists-trace
"Ex p rp1 rp2 ra1 ra2 R r_privk b #i #j #k #l #m #n.
    SubmittedPaper(p, abstractFromPaper(p), <commit(p, rp1), commit(p, rp2), commit(abstractFromPaper(p), ra1), commit(abstractFromPaper(p), ra2)>) @i
    & CommitPaper(commit(p, rp1)) @j
    & CommitAbstract(commit(abstractFromPaper(p), ra1)) @j
    & BidOnAbstract(R, r_privk, abstractFromPaper(p), ra2, b) @k
    & CommitBid(revealSign(<commit(abstractFromPaper(p), ra2), b>, r_privk)) @l
    & ReviewedPaper(R, p) @m
    & ReceivedReview(R, p) @n
"

// lemma sanity_multiple_submissions:
// exists-trace
// "Ex p1 a1 p2 a2 r1 r2 #i #j #k #l.
//     SubmittedPaper(p1, a1, r1) @i &
//     CommitPaper(commit(p1, r1)) @k &
//     CommitAbstract(commit(a1, r1)) @k &
//     SubmittedPaper(p2, a2, r2) @j &
//     CommitPaper(commit(p2, r2)) @l &
//     CommitAbstract(commit(a2, r2)) @l &
//     not(p1 = p2) &
//     not(a1 = a2) &
//     not(r1 = r2) &
//     i < k &
//     j < l
// "

//Restrictions
restriction Eq:
" All x y #i. Eq(x,y) @i ==> x = y
    
"

// restriction NotEq:
// " All x y #i. NotEq(x,y) @i ==> not(x = y)
    
// "

restriction OnlyOnceWith:
" All x #i #j. OnlyOnceWith(x) @i & OnlyOnceWith(x) @j ==> #i=#j
    
"

end