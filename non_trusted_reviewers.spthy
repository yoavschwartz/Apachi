theory untrusted_reviewers
begin

/*
 *  Author: Yoav.s&Nicolai.s
 *  Model Name: untrusted_reviewers.spthy
 *  Status: DEVELOPMENTAL
 *
 */

builtins: symmetric-encryption, hashing, asymmetric-encryption, revealing-signing
functions: commit/2, makeDiscussion/1, makeGrade/1, makeReview/2 [private], paper/1, randomness/1
heuristic: i


rule TestOut:
    [TestOut(m)]
  --[]->
    [!Test(m)]

rule TestIn:
    [!Test(m)]
  --[]->
    [TestIn(m)]

rule PublicTestIn:
    [In(m)]
  --[AdversaryIn()]->
    [TestIn(m)]

rule PublicTestOut:
    [!Test(m)]
  --[AdversaryOut()]->
    [Out(m)]


/*
 * Setting up our own secure, authenticated and replay resistant channels.
 * A: Sender
 * B: Receiver
 * x: message
 */
rule Setup: 
    let 
    pc_pubk = pk(~pc_privk)
    in
    [Fr(~pc_privk)]
  --[OnlyOnceWith('Setup'), KeySecret(~pc_privk)]->
    [Setup_Submitter(pc_pubk), 
     Setup_PC($PC, ~pc_privk), 
     !Setup_Reviewer(pc_pubk)]

rule Setup_submitter:
    let
    pc_pubk = pk(~pc_privk)
    in
    [Setup_Submitter(pc_pubk), Fr(~submitter_key), Fr(~S_privk)]
  --[OnlyOnceWith(<'Setup_Submitter', $Submitter>),
     KeySecret(~submitter_key),
     KeySecret(~S_privk),
     SubmitterKeyCreated(~submitter_key)]->
    [!Submitter_Ready_To_Submit($Submitter, pc_pubk, ~submitter_key, ~S_privk)]

rule Setup_pc:
    [Setup_PC($PC, ~pc_privk)]
  --[OnlyOnceWith('Setup_PC')]->
    [!PC($PC, ~pc_privk), Out(pk(~pc_privk))]

rule Setup_reviewer:
    let
    pc_pubk = pk(~pc_privk)
    in
    [!Setup_Reviewer(pc_pubk), Fr(~reviewer_key), Fr(~reviewer_privk)]
  --[ReviewerSetup($Reviewer, ~reviewer_key, ~reviewer_privk),
     OnlyOnceWith(<'Setup_Reviewer', $Reviewer>),
     KeySecret(~reviewer_key),
     KeySecret(~reviewer_privk)]->
    [!PC_Reviewer_Association($Reviewer, ~reviewer_key, pk(~reviewer_privk)),
     !Reviewer($Reviewer, ~reviewer_key, ~reviewer_privk, pc_pubk)]

/*
rule Make_submission:
  let
    paper_commit = commit(paper(~paper), randomness(~r_submit)) 
    submission = <senc(<paper(~paper), randomness(~r_submit), randomness(~r_review)>, ~submitter_key), aenc(~submitter_key, pk(~pc_privk)), paper_commit>
    signed_submission = revealSign(submission, ~S_privk)
  in
    [Fr(~paper), Fr(~r_submit), Fr(~r_review), Fr(~S_privk), Fr(~submitter_key), !PC($PC, ~pc_privk)]
  --[]->
    [Out(signed_submission), Out(<~paper, ~r_submit, ~r_review, ~S_privk, ~submitter_key>)]
*/

/*
Phase 1: Submission
1. Submitter send paper and abstract to S
2. S sends submitter a receipt
3. S sends papers to PC
4. PC publicly commits to submitted papers and whether or not they will go forward in the process
*/

rule Submission_1_submitter_submits:
  let
    paper_commit = commit(paper(~paper), randomness(~r_submit))
    signed_paper_commit = revealSign(paper_commit, ~S_privk)
    submission = senc(<paper(~paper), randomness(~r_submit), randomness(~r_review)>, ~submitter_key)
    signed_submission = revealSign(submission, ~S_privk)
    submission_key = aenc(~submitter_key, pk(~pc_privk))
    signed_submission_key = revealSign(submission_key, ~S_privk)
  in
    [Fr(~paper), Fr(~r_submit), Fr(~r_review), Fr(~r_id),
     !Submitter_Ready_To_Submit($Submitter, pk(~pc_privk), ~submitter_key, ~S_privk)]
  --[SubmittedPaperSecret(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key, ~pc_privk),
     SubmittedPaper(paper_commit),
     RandomSecret(~r_review),
     RandomSecret(~r_id),
     RandomSecret(~r_submit),
     PaperSecret(~paper),
     PaperSecret(paper(~paper)),
     PublicLog(signed_paper_commit),
     PublicLog(signed_submission),
     PublicLog(signed_submission_key)
     ]->
    [TestOut(signed_paper_commit),
     TestOut(signed_submission),
     TestOut(signed_submission_key)]

rule Submission_2_pc_receives_submission:
  let
    submission = senc(<paper(~paper), randomness(~r_submit), randomness(~r_review)>, ~submitter_key)
    submission_key = aenc(~submitter_key, pk(~pc_privk))

    paper_commit = commit(paper(~paper), randomness(~r_submit))
    signed_paper_commit = revealSign(paper_commit, ~pc_privk)
  in
    [!PC($PC, ~pc_privk),
     TestIn(revealSign(submission, ~S_privk)),
     TestIn(revealSign(submission_key, ~S_privk)),
     TestIn(revealSign(paper_commit,~S_privk))]
  --[PCReceivedPaper(paper_commit),
     OnlyOnceWith(<'Submission_1', ~paper>),
     PublicLog(signed_paper_commit)]->
    [!Received_Submission(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key), 
     TestOut(signed_paper_commit)]

rule Submission_2_pc_receives_submission_misbehaving:
  let
    paper_commit = commit(paper(~paper), randomness(~r_submit))
  in
    [!PC($PC, ~pc_privk),
     Fr(~paper), Fr(~r_submit), Fr(~r_review), Fr(~submitter_key)]
  --[OnlyOnceWith(<'Submission_1', ~paper>),
     MisbehavingPC(paper(~paper)),
     MisbehavingActor(paper(~paper))]->
    [!Received_Submission(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key)]


/*
Phase 2: Matching
1. PC sends a list of all papers
2. Reviewers sends a list of bids
3. PC receives bids
4. PC publishes the matching and creates the review groups
*/

rule Matching_1_pc_sends_papers:
  let
    encrypted_paper = revealSign(senc(paper(~paper), ~reviewer_key), ~pc_privk)
  in
    [!PC_Reviewer_Association($Reviewer, ~reviewer_key, pk(~reviewer_privk)), 
     !Received_Submission(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key),
     !PC($PC, ~pc_privk)]
  --[OnlyOnceWith(<'Matching_1', $Reviewer, ~paper>),
     PCSendsPaperToReviewer($Reviewer, paper(~paper)),
     PublicLog(encrypted_paper)]->
    [TestOut(encrypted_paper)]

rule Matching_2_reviewer_sends_bids:
  let
  	encrypted_paper = revealSign(senc(paper(~paper), ~reviewer_key), ~pc_privk)

  	encrypted_bid = senc(<h(paper(~paper)), 'bid'>, ~reviewer_key)
    signed_encrypted_bid = revealSign(encrypted_bid, ~reviewer_privk)
  in
    [!Reviewer($Reviewer, ~reviewer_key, ~reviewer_privk, pc_pubk),
     TestIn(encrypted_paper)]
  --[BidOnPaper($Reviewer, ~reviewer_key, paper(~paper)),
     OnlyOnceWith(<'Matching_2', $Reviewer, ~paper>),
     PublicLog(signed_encrypted_bid)]->
    [Reviewer_Bid_On_Paper($Reviewer, paper(~paper)),
     TestOut(signed_encrypted_bid)]

rule Matching_3_pc_receives_bid:
  let
    encrypted_bid = senc(<h(paper(~paper)), 'bid'>, ~reviewer_key)
    signed_encrypted_bid = revealSign(encrypted_bid, ~reviewer_privk)
  in
    [!Received_Submission(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key),
     !PC_Reviewer_Association($Reviewer, ~reviewer_key, pk(~reviewer_privk)),
     TestIn(signed_encrypted_bid)]
  --[PCReceivedBid($Reviewer, 'bid', paper(~paper)),
  	 OnlyOnceWith(<'Matching_3', $Reviewer, ~paper>)]->
    [Matching_Ready($Reviewer, pk(~reviewer_privk), paper(~paper))]

rule Matching_4_pc_matches_paper:
  let
    review_paper_commit = commit(paper(~paper), randomness(~r_review))
    matching = revealSign(<review_paper_commit, pk(~reviewer_privk)>, ~pc_privk)
    matching_secret = revealSign(senc(<h(paper(~paper)), ~group_key, randomness(~r_grade), randomness(~r_review)>, ~reviewer_key), ~pc_privk)
  in
    [Fr(~group_key), Fr(~r_grade), !PC($PC, ~pc_privk),
     !PC_Reviewer_Association($Reviewer, ~reviewer_key, pk(~reviewer_privk)),
     !Received_Submission(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key),
     Matching_Ready($Reviewer, pk(~reviewer_privk), paper(~paper))]
  --[MatchedPaper(paper(~paper), $Reviewer, ~group_key),
     OnlyOnceWith(<'Matching_4', $Reviewer, ~paper>),
     KeySecret(~group_key),
     RandomSecret(~r_grade),
     PublicLog(matching),
     PublicLog(matching_secret)]->
    [PC_Waiting_For_Discussion(paper(~paper), randomness(~r_grade), $Reviewer, ~group_key),
     TestOut(matching),
     TestOut(matching_secret)]

/*
Phase 3: Reviewing
1. Reviewer sends review text and score signs the review text and score and sings a commit to the paper
*/

rule Reviewing_1_reviewer_sends_review:
  let
    review_paper_commit = commit(paper(~paper), randomness(~r_review))
  	matching = revealSign(<review_paper_commit, pk(~reviewer_privk)>, ~pc_privk)
  	matching_secret = revealSign(senc(<h(paper(~paper)), ~group_key, randomness(~r_grade), randomness(~r_review)>, ~reviewer_key), ~pc_privk)

    review = makeReview(paper(~paper), $Reviewer)
  	group_message = senc(revealSign(<review>, ~reviewer_privk), ~group_key)
  	commit_paper_reviewed = revealSign(<review_paper_commit, 'reviewed'>, ~reviewer_privk)
  in
    [Reviewer_Bid_On_Paper($Reviewer, paper(~paper)),
     !Reviewer($Reviewer, ~reviewer_key, ~reviewer_privk, pk(~pc_privk)),
     TestIn(matching),
     TestIn(matching_secret)]
  --[ReviewedPaper($Reviewer, paper(~paper), ~group_key),
     SecretReview(review),
     PublicLog(group_message),
     PublicLog(commit_paper_reviewed)]->
    [!Reviewer_Reviewed_Paper($Reviewer, paper(~paper), randomness(~r_review), randomness(~r_grade), ~group_key),
     Discussing($Reviewer, paper(~paper)),
     TestOut(group_message),
     TestOut(commit_paper_reviewed)]

/*
Phase 4: Discussion
1. Reviewer discuss and settle on a grade/recommendation and sends to PC
2. PC receives discussion and grade
3. PC picks paper
*/

rule Discussion_1_1_reviewers_discuss:
  let
    discussion = makeDiscussion(paper(~paper))
    encrypted_discussion = senc(revealSign(discussion, ~reviewer_privk), ~group_key)
  in
    [!Reviewer_Reviewed_Paper($Reviewer, paper(~paper), randomness(~r_review), randomness(~r_grade), ~group_key),
     !Reviewer($Reviewer, ~reviewer_key, ~reviewer_privk, pc_pubk),
     Discussing($Reviewer, paper(~paper))]
  --[DiscussedPaper($Reviewer, paper(~paper), ~group_key),
     OnlyOnceWith(<'Discussion_1_1', $Reviewer, ~paper>),
     PublicLog(encrypted_discussion)]->
    [Discussing($Reviewer, paper(~paper)),
     TestOut(encrypted_discussion)]

rule Discussion_1_2_finished_discussing:
  let
  	grade = makeGrade(paper(~paper))  
    encrypted_conclusion = senc(revealSign(grade, ~reviewer_privk), ~group_key)
  	paper_review_commit = commit(paper(~paper), randomness(~r_review))
  	commit_paper_discussed = revealSign(<paper_review_commit, 'discussed'>, ~reviewer_privk)
  	commit_paper_grade = revealSign(commit(grade, randomness(~r_grade)), ~reviewer_privk)
  	commit_pair = <commit_paper_discussed, commit_paper_grade>
  in
    [Discussing($Reviewer, paper(~paper)),
     !Reviewer($Reviewer, ~reviewer_key, ~reviewer_privk, pc_pubk),
     !Reviewer_Reviewed_Paper($Reviewer, paper(~paper), randomness(~r_review), randomness(~r_grade), ~group_key)]
  --[PublicLog(encrypted_conclusion),
     PublicLog(commit_pair)]-> 
    [TestOut(encrypted_conclusion), 
     TestOut(commit_pair)]

rule Discussion_2_pc_receives_discussion_and_grade:
  let
    discussion = makeDiscussion(paper(~paper))
    grade = makeGrade(paper(~paper))
    encrypted_discussion = senc(revealSign(discussion, ~reviewer_privk), ~group_key)
    encrypted_conclusion = senc(revealSign(grade, ~reviewer_privk), ~group_key)
    group_message = senc(revealSign(<makeReview(paper(~paper), $Reviewer)>, ~reviewer_privk), ~group_key)
    
    submitter_response = senc(<discussion, grade, makeReview(paper(~paper), $Reviewer)>, ~submitter_key)
  in
    [PC_Waiting_For_Discussion(paper(~paper), randomness(~r_grade), $Reviewer, ~group_key),
     !PC_Reviewer_Association($Reviewer, ~reviewer_key, pk(~reviewer_privk)),
     !Received_Submission(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key),
     TestIn(encrypted_conclusion),
     TestIn(group_message)]
  --[PCReceivedDiscussionFromReviewer($Reviewer, paper(~paper), ~group_key),
     OnlyOnceWith(<'Discussion_2', paper(~paper), $Reviewer>),
     SubmitterKeyUsed(~submitter_key),
     PublicLog(submitter_response)]->
    [Ready_For_Decision($Reviewer, paper(~paper), grade, randomness(~r_submit), randomness(~r_review), randomness(~r_grade), ~reviewer_privk, ~group_key), 
     TestOut(submitter_response)]

rule Discussion_3_pc_paper_accepted:
  let
    accepted = <paper(~paper), randomness(~r_submit), randomness(~r_review)>
    signed_accepted = revealSign(accepted, ~pc_privk)
    signed_grade = revealSign(grade, ~pc_privk)
  in
    [!PC($PC, ~pc_privk),
     Ready_For_Decision($Reviewer, paper(~paper), grade, randomness(~r_submit), randomness(~r_review), randomness(~r_grade), ~reviewer_privk, ~group_key)]
  --[PaperAccepted($Reviewer, paper(~paper)),
     RandomReveal(~r_submit),
     RandomReveal(~r_review),
     OnlyOnceWith(<'conclusion', ~paper>),
     PublicLog(signed_accepted),
     PublicLog(signed_grade)]->
    [TestOut(signed_accepted), 
     TestOut(signed_grade)]

rule Discussion_3_pc_paper_rejected:
  let
    group_message = senc(revealSign(<makeReview(paper(~paper), $Reviewer)>, ~reviewer_privk), ~group_key)
    rejected_out = revealSign(<randomness(~r_grade), grade>, ~pc_privk)
  in
    [!PC($PC, ~pc_privk),
     TestIn(group_message),
     Ready_For_Decision($Reviewer, paper(~paper), grade, randomness(~r_submit), randomness(~r_review), randomness(~r_grade), ~reviewer_privk, ~group_key)]
  --[PaperRejected($Reviewer, paper(~paper)),
     RandomReveal(~r_grade),
     OnlyOnceWith(<'conclusion', ~paper>),
     PublicLog(rejected_out)]->
    [TestOut(rejected_out)]

lemma key_secret [reuse, use_induction]:
all-traces 
"All k #i. KeySecret(k) @i ==> not(Ex #j. K(k) @j)
"

/*
lemma paper_secret [reuse, use_induction]:
all-traces 
"All p #i. PaperSecret(p) @i ==> not(Ex #j. K(p) @j)
"
*/
/*
lemma randomness_secret [reuse]:
all-traces 
"All r #i. RandomSecret(r) @i ==> not(Ex #j. KU(r) @j) | (Ex #j. RandomReveal(r) @j) 
"
*/



lemma paper_secrecy_accepted [reuse]:
"All p r #i #j.
 SubmittedPaper(commit(p,r)) @i &
 K(p) @j 
 ==> 
 Ex R #k. PaperAccepted(R, p) @k
"

lemma paper_secrecy_rejected [reuse]:
"All p r R #i #j.
 SubmittedPaper(commit(p,r)) @i &
 PaperRejected(R, p) @j 
 ==> 
 not(Ex #k. K(p) @k)
"

lemma review_secrecy [reuse]:
"All R p r #i #j. 
 SubmittedPaper(commit(p,r)) @i &
 SecretReview(makeReview(p, R)) @j ==> not(Ex #k. K(makeReview(p, R)) @k)
"

// Verifiability paper accepted was submitted
lemma paper_accepted_was_submitted_verifiabillity_completeness:
"All  p r_submit r_review pc_privk #k.
  PublicLog(revealSign(<p, r_submit, r_review>, pc_privk)) @k &
  not(Ex #a. AdversaryIn() @a) &
  not(Ex #a. AdversaryOut() @a) &
  not(Ex #a. MisbehavingActor(p) @a)
==>
(Ex s_privk #i #j.
  PublicLog(revealSign(commit(p, r_submit), s_privk)) @i &
  PublicLog(revealSign(commit(p, r_submit), pc_privk)) @j &
  i < j &
  j < k &
  not(s_privk = pc_privk)
  )
"

lemma paper_accepted_was_submitted_verifiability_soundness_1_exists_trace_where_false:
exists-trace
"Ex p r_submit r_review pc_privk #k.
  PublicLog(revealSign(<p, r_submit, r_review>, pc_privk)) @k &
  not(
    (Ex s_privk #i. PublicLog(revealSign(commit(p, r_submit), s_privk))@i & i < k) |
    (Ex #i. PublicLog(revealSign(commit(p, r_submit), pc_privk))@i & i < k)
  )
"

lemma paper_accepted_was_submitted_verifiability_soundness_2_true_no_adversary:
"All p r_submit r_review s_privk pc_privk #i #j #k.
  PublicLog(revealSign(<p, r_submit, r_review>, pc_privk)) @k &
  PublicLog(revealSign(commit(p, r_submit), s_privk)) @i &
  PublicLog(revealSign(commit(p, r_submit), pc_privk)) @j &
  i < j &
  j < k &
  not(s_privk = pc_privk)
==>
  not(Ex #a. MisbehavingActor(p) @a)
"


lemma sanity_one:
exists-trace
"Ex R p r R_key R_privk b g_k #h #i #j #k #l #m #n #o #p #q #r.
    ReviewerSetup(R, R_key, R_privk) @h
    & SubmittedPaper(commit(p,r)) @i
    & PCReceivedPaper(commit(p,r)) @j
    & PCSendsPaperToReviewer(R, p) @k
    & BidOnPaper(R, R_key, p) @l
    & PCReceivedBid(R, b, p) @m
    & MatchedPaper(p, R, g_k) @n
    & ReviewedPaper(R, p, g_k) @o
    & DiscussedPaper(R, p, g_k) @p
    & PCReceivedDiscussionFromReviewer(R, p, g_k) @q
    & PaperAccepted(R, p) @r
"

lemma sanity_only_paper_accepted:
exists-trace
"Ex R p #r. 
   PaperAccepted(R, p) @r
"

lemma sanity_only_paper_rejected:
exists-trace
"Ex R p #r. 
   PaperRejected(R, p) @r
"

//Restrictions
// restriction Eq:
// " All x y #i. Eq(x,y) @i ==> x = y
    
// "

restriction OnlyOnceWith:
" All x #i #j. OnlyOnceWith(x) @i & OnlyOnceWith(x) @j ==> #i=#j
    
"

end