theory untrusted_reviewers
begin

/*
 *  Author: 
 *  Model Name: x.spthy
 *  Status: DEVELOPMENTAL
 *
 */

builtins: symmetric-encryption, hashing, asymmetric-encryption, revealing-signing
functions: commit/2, makeDiscussion/1, makeGrade/1, makeReview/2 [private], paper/1, randomness/1


rule TestOut:
    [TestOut(m)]
  --[]->
    [!Test(m)]

rule TestIn:
    [!Test(m)]
  --[]->
    [TestIn(m)]

rule PublicTestIn:
    [In(m)]
  --[]->
    [TestIn(m)]

rule PublicTestOut:
    [!Test(m)]
  --[]->
    [Out(m)]

/*
 * Setting up our own secure, authenticated and replay resistant channels.
 * A: Sender
 * B: Receiver
 * x: message
 */
rule Setup: 
    let 
    pc_pubk = pk(~pc_privk)
    in
    [Fr(~pc_privk)]
  --[OnlyOnceWith('Setup'), KeySecret(~pc_privk)]->
    [Setup_Submitter(pc_pubk), 
     Setup_PC($PC, ~pc_privk), 
     Setup_Reviewer(pc_pubk), Setup_Reviewer(pc_pubk), Setup_Reviewer(pc_pubk)]

rule Setup_submitter:
    let
    pc_pubk = pk(~pc_privk)
    in
    [Setup_Submitter(pc_pubk), Fr(~key), Fr(~S_privk)]
  --[OnlyOnceWith(<'setup_submitter', $Submitter>),
     KeySecret(~key),
     KeySecret(~S_privk),
     SubmitterKeyCreated(~key)]->
    [!Submitter_Ready_To_Submit($Submitter, pc_pubk, ~key, ~S_privk)]

rule Setup_pc:
    [Setup_PC($PC, ~pc_privk)]
  --[OnlyOnceWith('setup_pc')]->
    [!PC($PC, ~pc_privk), Out(pk(~pc_privk))]

rule Setup_reviewer:
    let
    pc_pubk = pk(~pc_privk)
    in
    [Setup_Reviewer(pc_pubk), Fr(~key), Fr(~reviewer_privk)]
  --[ReviewerSetup($Reviewer, ~key, ~reviewer_privk),
     OnlyOnceWith(<'setup_reviewer', $Reviewer>),
     KeySecret(~key),
     KeySecret(~reviewer_privk)]->
    [!PC_Reviewer_Association($Reviewer, ~key, pk(~reviewer_privk)),
     !Reviewer($Reviewer, ~key, ~reviewer_privk, pc_pubk)]

/*
Phase 1: Submission
1. Submitter send paper and abstract to S
2. S sends submitter a receipt
3. S sends papers to PC
4. PC publicly commits to submitted papers and whether or not they will go forward in the process
*/

rule Submission_1_submitter_submits:
  let
    paper_commit = commit(paper(~paper), randomness(~r_submit)) 
    identity_commit = commit($Submitter, ~r_id)
    submission = <senc(<paper(~paper), randomness(~r_submit), randomness(~r_review)>, ~key), aenc(~key, pc_pubk), paper_commit, identity_commit>
    signed_submission = revealSign(submission, ~S_privk)
  in
    [Fr(~paper), Fr(~r_submit), Fr(~r_review), Fr(~r_id),
     !Submitter_Ready_To_Submit($Submitter, pc_pubk, ~key, ~S_privk)]
  --[SubmittedPaper(paper_commit),
     RandomSecret(~r_review),
     RandomSecret(~r_id),
     RandomSecret(~r_submit)]->
    [TestOut(signed_submission)]

rule Submission_2_pc_receives_submission:
  let
  	paper_commit = commit(paper(~paper), randomness(~r_submit))
    identity_commit = commit($Submitter, ~r_id)
    submission = <senc(<paper(~paper), randomness(~r_submit), randomness(~r_review)>, ~submitter_key), aenc(~key, pc_pubk), paper_commit, identity_commit>
    signed_submission = revealSign(submission, ~S_privk)
  in
    [!PC($PC, ~pc_privk),
     TestIn(signed_submission)]
  --[PCReceivedPaper(paper_commit),
     OnlyOnceWith(<'submission', ~paper>)]->
    [!Received_Submission(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key), 
     TestOut(revealSign(paper_commit, ~pc_privk))]


/*
Phase 2: Matching
1. PC sends a list of all papers
2. Reviewers sends a list of bids
3. PC receives bids
4. PC publishes the matching and creates the review groups
*/

rule Matching_1_pc_sends_papers:
  let
    encrypted_paper = revealSign(senc(paper(~paper), ~reviewer_key), ~pc_privk)
  in
    [!PC_Reviewer_Association($Reviewer, ~reviewer_key, reviewer_pubk), 
     !Received_Submission(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key),
     !PC($PC, ~pc_privk)]
  --[OnlyOnceWith(<'Matching_1', encrypted_paper, $Reviewer>),
      PCSendsPaperToReviewer($Reviewer, encrypted_paper)]->
    [TestOut(encrypted_paper)]

rule Matching_2_reviewer_sends_bids:
  let
  	encrypted_paper = revealSign(senc(paper(~paper), ~reviewer_key), ~pc_privk)
  	encrypted_bid = senc(<paper(~paper), 'bid'>, ~reviewer_key)
    signed_encrypted_bid = revealSign(encrypted_bid, ~reviewer_privk)
  in
    [!Reviewer($Reviewer, ~reviewer_key, ~reviewer_privk, pc_pubk),
     TestIn(encrypted_paper)]
  --[BidOnPaper($Reviewer, ~reviewer_key, paper(~paper)),
     OnlyOnceWith(<'Matching_2', $Reviewer, paper(~paper)>)]->
    [Reviewer_Bid_On_Paper($Reviewer, paper(~paper)),
     TestOut(signed_encrypted_bid)]

rule Matching_3_pc_receives_bid:
  let
    encrypted_bid = senc(<paper(~paper), 'bid'>, ~reviewer_key)
    signed_encrypted_bid = revealSign(encrypted_bid, ~reviewer_privk)
  in
    [!Received_Submission(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key),
     !PC_Reviewer_Association($Reviewer, ~reviewer_key, pk(~reviewer_privk)),
     TestIn(signed_encrypted_bid)]
  --[PCReceivedBid($Reviewer, 'bid'),
  	 OnlyOnceWith(<'Matching_3', $Reviewer, paper(~paper)>)]->
    [Matching_Ready($Reviewer, pk(~reviewer_privk), paper(~paper))]

rule Matching_4_pc_matches_paper:
  let
    review_paper_commit = commit(paper(~paper), randomness(~r_review))
    matching1 = revealSign(<review_paper_commit, pk(~reviewer_privk1)>, ~pc_privk)
    matching2 = revealSign(<review_paper_commit, pk(~reviewer_privk2)>, ~pc_privk)
    matching3 = revealSign(<review_paper_commit, pk(~reviewer_privk3)>, ~pc_privk)
    matching_secret1 = revealSign(senc(<paper(~paper), ~group_key, randomness(~r_grade), randomness(~r_review)>, ~reviewer_key1), ~pc_privk)
    matching_secret2 = revealSign(senc(<paper(~paper), ~group_key, randomness(~r_grade), randomness(~r_review)>, ~reviewer_key2), ~pc_privk)
    matching_secret3 = revealSign(senc(<paper(~paper), ~group_key, randomness(~r_grade), randomness(~r_review)>, ~reviewer_key3), ~pc_privk)
  in
    [Fr(~group_key), Fr(~r_grade), !PC($PC, ~pc_privk),
     !PC_Reviewer_Association($Reviewer1, ~reviewer_key1, pk(~reviewer_privk1)),
     !PC_Reviewer_Association($Reviewer2, ~reviewer_key2, pk(~reviewer_privk2)),
     !PC_Reviewer_Association($Reviewer3, ~reviewer_key3, pk(~reviewer_privk3)),
     !Received_Submission(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key),
     Matching_Ready($Reviewer1, pk(~reviewer_privk1), paper(~paper)),
     Matching_Ready($Reviewer2, pk(~reviewer_privk2), paper(~paper)),
     Matching_Ready($Reviewer3, pk(~reviewer_privk3), paper(~paper))]
  --[MatchedPaper(paper(~paper), $Reviewer1, $Reviewer2, $Reviewer3, ~group_key),
     OnlyOnceWith(<'matched_paper', paper(~paper)>),
     KeySecret(~group_key),
     RandomSecret(~r_grade)]->
    [PC_Waiting_For_Discussion(paper(~paper), randomness(~r_grade), $Reviewer1, $Reviewer2, $Reviewer3, ~group_key),
     TestOut(matching1), TestOut(matching2), TestOut(matching3),
     TestOut(matching_secret1), TestOut(matching_secret2), TestOut(matching_secret3)]

/*
Phase 3: Reviewing
1. Reviewer sends review text and score signs the review text and score and sings a commit to the paper
*/


rule Reviewing_1_reviewer_sends_review:
  let
    review_paper_commit = commit(paper(~paper), randomness(~r_review))
  	matching = revealSign(<review_paper_commit, pk(~reviewer_privk)>, ~pc_privk)
  	matching_secret = revealSign(senc(<paper(~paper), ~group_key, randomness(~r_grade), randomness(~r_review)>, ~reviewer_key), ~pc_privk)

    review = makeReview(paper(~paper), $Reviewer)
  	group_message = senc(revealSign(<review>, ~reviewer_privk), ~group_key)
  	commit_paper_reviewed = revealSign(<review_paper_commit, 'reviewed'>, ~reviewer_privk)
  in
    [Reviewer_Bid_On_Paper($Reviewer, paper(~paper)),
     !Reviewer($Reviewer, ~reviewer_key, ~reviewer_privk, pc_pubk),
     TestIn(matching), TestIn(matching_secret)]
  --[ReviewedPaper($Reviewer, paper(~paper), ~group_key),
     SecretReview(review)]->
    [Reviewer_Reviewed_Paper($Reviewer, paper(~paper), randomness(~r_review), randomness(~r_grade)),
     TestOut(group_message), TestOut(commit_paper_reviewed)]

/*
Phase 4: Discussion
1. Reviewer discuss and settle on a grade/recommendation and sends to PC
2. PC receives discussion and grade
3. PC picks paper
*/

rule Discussion_1_reviewers_discuss:
  let
  	group_message2 = senc(revealSign(<makeReview(paper(~paper), $Reviewer2)>, ~reviewer_privk2), ~group_key)
  	group_message3 = senc(revealSign(<makeReview(paper(~paper), $Reviewer3)>, ~reviewer_privk3), ~group_key)


  	discussion = makeDiscussion(paper(~paper))
  	grade = makeGrade(paper(~paper))  
  	paper_review_commit = commit(paper(~paper), randomness(~r_review))
  	commit_paper_discussed = revealSign(<paper_review_commit, 'discussed'>, ~reviewer_privk)
  	commit_paper_grade = revealSign(commit(grade, randomness(~r_grade)), ~reviewer_privk)
  	commit_pair = <commit_paper_discussed, commit_paper_grade>

  	encrypted_conclusion = senc(revealSign(<discussion, grade>, ~reviewer_privk), ~group_key)
  in
    [Reviewer_Reviewed_Paper($Reviewer, paper(~paper), randomness(~r_review), randomness(~r_grade)),
     !Reviewer($Reviewer, ~key, ~reviewer_privk, pc_pubk),
     TestIn(group_message2), TestIn(group_message3)]
  --[DiscussedPaper($Reviewer, paper(~paper), ~group_key),
     NotEq(~reviewer_privk, ~reviewer_privk2),
  	 NotEq(~reviewer_privk, ~reviewer_privk3),
     NotEq(~reviewer_privk2, ~reviewer_privk3)]->
    [TestOut(encrypted_conclusion), TestOut(commit_pair)]

rule Discussion_2_pc_receives_discussion_and_grade:
  let
    discussion = makeDiscussion(paper(~paper))
    grade = makeGrade(paper(~paper))
    encrypted_conclusion1 = senc(revealSign(<discussion, grade>, ~reviewer_privk1), ~group_key)
    encrypted_conclusion2 = senc(revealSign(<discussion, grade>, ~reviewer_privk2), ~group_key)
    encrypted_conclusion3 = senc(revealSign(<discussion, grade>, ~reviewer_privk3), ~group_key)

    group_message1 = senc(revealSign(<makeReview(paper(~paper), $Reviewer1)>, ~reviewer_privk1), ~group_key)
    group_message2 = senc(revealSign(<makeReview(paper(~paper), $Reviewer2)>, ~reviewer_privk2), ~group_key)
    group_message3 = senc(revealSign(<makeReview(paper(~paper), $Reviewer3)>, ~reviewer_privk3), ~group_key)

    sumbitter_response = senc(<discussion, grade, makeReview(paper(~paper), $Reviewer1), makeReview(paper(~paper), $Reviewer2), makeReview(paper(~paper), $Reviewer3)>, ~submitter_key)
  in
    [PC_Waiting_For_Discussion(paper(~paper), randomness(~r_grade), $Reviewer1, $Reviewer2, $Reviewer3, ~group_key),
     !PC_Reviewer_Association($Reviewer1, ~reviewer_key1, pk(~reviewer_privk1)),
     !PC_Reviewer_Association($Reviewer2, ~reviewer_key2, pk(~reviewer_privk2)),
     !PC_Reviewer_Association($Reviewer3, ~reviewer_key3, pk(~reviewer_privk3)),
     !Received_Submission(paper(~paper), randomness(~r_submit), randomness(~r_review), ~submitter_key),
     TestIn(encrypted_conclusion1),
     TestIn(encrypted_conclusion2),
     TestIn(encrypted_conclusion3),
     TestIn(group_message1),
     TestIn(group_message2),
     TestIn(group_message3)]
  --[PCReceivedDiscussionFromReviewer($Reviewer1, paper(~paper), ~group_key),
     PCReceivedDiscussionFromReviewer($Reviewer2, paper(~paper), ~group_key),
     PCReceivedDiscussionFromReviewer($Reviewer3, paper(~paper), ~group_key),
     OnlyOnceWith(<'PC_received_discussion', paper(~paper)>),
     NotEq(~reviewer_privk1, ~reviewer_privk2),
     NotEq(~reviewer_privk1, ~reviewer_privk3),
     NotEq(~reviewer_privk2, ~reviewer_privk3),
     SubmitterKeyUsed(~submitter_key)]->
    [Ready_For_Decision(paper(~paper), grade, randomness(~r_submit), randomness(~r_review), randomness(~r_grade), ~reviewer_privk1, ~reviewer_privk2, ~reviewer_privk3, ~group_key)
     ,TestOut(sumbitter_response)
     ]

rule Discussion_3_pc_paper_accepted:
  let
    accepted = <paper(~paper), randomness(~r_submit), randomness(~r_review)>
    signed_accepted = revealSign(accepted, ~pc_privk)
  in
    [!PC($PC, ~pc_privk),
     Ready_For_Decision(paper(~paper), grade, randomness(~r_submit), randomness(~r_review), randomness(~r_grade), ~reviewer_privk1, ~reviewer_privk2, ~reviewer_privk3, ~group_key)]
  --[PaperAccepted(paper(~paper)),
     RandomReveal(~r_submit),
     RandomReveal(~r_review)]->
    [TestOut(signed_accepted), TestOut(revealSign(grade, ~pc_privk))]

rule Discussion_3_pc_paper_rejected:
  let
    group_message1 = senc(revealSign(<makeReview(paper(~paper), $Reviewer1)>, ~reviewer_privk1), ~group_key)
    group_message2 = senc(revealSign(<makeReview(paper(~paper), $Reviewer2)>, ~reviewer_privk2), ~group_key)
    group_message3 = senc(revealSign(<makeReview(paper(~paper), $Reviewer3)>, ~reviewer_privk3), ~group_key)

    rejected_out = revealSign(<randomness(~r_grade), grade>, ~pc_privk)
  in
    [Setup_PC($PC, ~pc_privk),
     TestIn(group_message1), TestIn(group_message2), TestIn(group_message3),
     Ready_For_Decision(paper(~paper), grade, randomness(~r_submit), randomness(~r_review) ,randomness(~r_grade), ~reviewer_privk1, ~reviewer_privk2, ~reviewer_privk3, ~group_key)]
  --[PaperRejected(paper(~paper)),
     RandomReveal(~r_grade)]->
    [TestOut(rejected_out)]

lemma sanity_one:
exists-trace
"Ex R p r R2 R3 R_key R_privk b g_k #h #i #j #k #l #m #n #o #p #q #r.
    ReviewerSetup(R, R_key, R_privk) @h
    & SubmittedPaper(commit(p,r)) @i
    & PCReceivedPaper(commit(p,r)) @j
    & PCSendsPaperToReviewer(R, senc(p, R_key)) @k
    & BidOnPaper(R, R_key, p) @l
    & PCReceivedBid(R, b) @m
    & MatchedPaper(p, R, R2, R3, g_k) @n
    & ReviewedPaper(R, p, g_k) @o
    & DiscussedPaper(R, p, g_k) @p
    & PCReceivedDiscussionFromReviewer(R, p, g_k) @q
    & PaperAccepted(p) @r
"

lemma sanity_only_paper_accepted:
exists-trace
"Ex p #r. 
   PaperAccepted(p) @r
"

lemma sanity_only_paper_rejected:
exists-trace
"Ex p #r. 
   PaperRejected(p) @r
"

lemma key_secret [reuse, use_induction]:
all-traces 
"All k #i. KeySecret(k) @i ==> not(Ex #j. KU(k) @j)
"
/*
lemma randomness_secret [reuse]:
all-traces 
"All r #i. RandomSecret(r) @i ==> not(Ex #j. KU(r) @j) | (Ex #j. RandomReveal(r) @j) 
"
*/

lemma authentic_submitter [reuse, use_induction]:
"All k #i. SubmitterKeyUsed(k)@i ==> Ex #j. SubmitterKeyCreated(k) @j & j < i
"

lemma paper_secrecy [reuse]:
"All p r #i #j.
 SubmittedPaper(commit(p,r))@i &
 K(p)@j 
 ==> 
 Ex #k. PaperAccepted(p) @k
"

lemma review_secrecy:
"All R p r #i #j. 
SubmittedPaper(commit(p,r))@i &
SecretReview(makeReview(p, R)) @j ==> not(Ex #k. K(makeReview(p, R))@k)
"

//Restrictions
// restriction Eq:
// " All x y #i. Eq(x,y) @i ==> x = y
    
// "

restriction NotEq:
" All x y #i. NotEq(x,y) @i ==> not(x = y)
    
"

restriction OnlyOnceWith:
" All x #i #j. OnlyOnceWith(x) @i & OnlyOnceWith(x) @j ==> #i=#j
    
"

end